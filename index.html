<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prebeg Spanks-Giving</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Custom Styles -->
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .pattern-bg {
            background-image: radial-gradient(#f59e0b 1px, transparent 1px);
            background-size: 20px 20px;
        }
    </style>
</head>
<body class="bg-orange-50 pattern-bg min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- AUDIO ENGINE (Web Audio API) ---
        const SoundEngine = {
            ctx: null,
            init: () => {
                if (!SoundEngine.ctx) {
                    SoundEngine.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (SoundEngine.ctx.state === 'suspended') {
                    SoundEngine.ctx.resume();
                }
            },
            play: (type) => {
                SoundEngine.init();
                const ctx = SoundEngine.ctx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);

                const now = ctx.currentTime;

                switch (type) {
                    case 'click':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(600, now);
                        osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;
                    case 'step':
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(150, now);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;
                    case 'roll':
                        // Simple noise burst simulation
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(100, now);
                        osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                        gain.gain.setValueAtTime(0.05, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                        break;
                    case 'success':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.setValueAtTime(600, now + 0.1);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                    case 'fail':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(300, now);
                        osc.frequency.linearRampToValueAtTime(100, now + 0.3);
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                    case 'win':
                        osc.type = 'triangle';
                        // Arpeggio
                        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                            const osc2 = ctx.createOscillator();
                            const gain2 = ctx.createGain();
                            osc2.connect(gain2);
                            gain2.connect(ctx.destination);
                            osc2.frequency.value = freq;
                            gain2.gain.setValueAtTime(0.05, now + i*0.1);
                            gain2.gain.exponentialRampToValueAtTime(0.001, now + i*0.1 + 0.3);
                            osc2.start(now + i*0.1);
                            osc2.stop(now + i*0.1 + 0.3);
                        });
                        break;
                    case 'alert':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(800, now);
                        osc.frequency.setValueAtTime(400, now + 0.15);
                        gain.gain.setValueAtTime(0.05, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                     case 'shield':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(200, now);
                        osc.frequency.linearRampToValueAtTime(800, now + 0.1);
                        gain.gain.setValueAtTime(0.05, now);
                        gain.gain.linearRampToValueAtTime(0, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                }
            }
        };

        // --- ICONS (SVG Components) ---
        const Icon = ({ path, className = "w-6 h-6", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}><path d={path} /></svg>
        );

        // Reusing existing icons and adding new ones
        const Drumstick = (props) => <Icon path="M15.45 13.9 19 19l-1.6 2.4a2.9 2.9 0 0 1-4.8-.3L8.5 14.5a3.5 3.5 0 0 1-1.3-4.1l.8-2.6 1.8 1.8a2 2 0 0 0 2.8 0l1.1-1.1a2 2 0 0 0 0-2.8l-1.8-1.8 2.6-.8a3.5 3.5 0 0 1 4.1 1.3L21 8.5l-5.55 5.4Z" {...props} />;
        const Shield = (props) => <Icon path="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" {...props} />;
        const Skull = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="9" cy="12" r="1"/><circle cx="15" cy="12" r="1"/><path d="M8 20v2h8v-2"/><path d="M12.5 17l-.5-1-.5 1h1z"/><path d="M16 20a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20"/></svg>;
        const ArrowRight = (props) => <Icon path="M5 12h14M12 5l7 7-7 7" {...props} />;
        const Dna = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M2 15c6.667-6 13.333 0 20-6"/><path d="M9 22c1.798-1.998 2.518-3.995 2.807-5.993"/><path d="M15 2c-1.798 1.998-2.518 3.995-2.807 5.993"/><path d="M17 12a5.002 5.002 0 0 0-3 7"/><path d="M12 12a5.002 5.002 0 0 0 4-3"/></svg>;
        const Utensils = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M3 2v7c0 1.1.9 2 2 2h4a2 2 0 0 0 2-2V2"/><path d="M7 2v20"/><path d="M21 15V2v0a5 5 0 0 0-5 5v6c0 1.1.9 2 2 2h3Zm0 0v7"/></svg>;
        const AlertTriangle = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg>;
        const Edit2 = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>;
        const Info = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>;
        const Star = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>;
        const Ghost = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M9 10h.01"/><path d="M15 10h.01"/><path d="M12 2a8 8 0 0 0-8 8v12l3-3 2.5 2.5L12 19l2.5 2.5L17 19l3 3V10a8 8 0 0 0-8-8z"/></svg>;
        const Swords = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5"/><line x1="13" y1="19" x2="19" y2="13"/><line x1="16" y1="16" x2="20" y2="20"/><line x1="19" y1="21" x2="21" y2="19"/><polyline points="14.5 6.5 18 3 21 3 21 6 17.5 9.5"/><line x1="5" y1="14" x2="9" y2="18"/><line x1="7" y1="17" x2="4" y2="20"/><line x1="3" y1="19" x2="5" y2="21"/></svg>;
        const Eye = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>;
        const Crown = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14"/></svg>;
        const Megaphone = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m3 11 18-5v12L3 14v-3z"/><path d="M11.6 16.8a3 3 0 1 1-5.8-1.6"/></svg>;
        const Pizza = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M15 11h.01"/><path d="M11 15h.01"/><path d="M16 16h.01"/><path d="m2 16 20 6-6-20A20 20 0 0 0 2 16"/></svg>;
        const Glasses = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="6" cy="15" r="4"/><circle cx="18" cy="15" r="4"/><path d="M14 15a2 2 0 0 0-2-2 2 2 0 0 0-2 2"/><path d="M2.5 13 5 7c.7-1.3 1.4-2 3-2"/><path d="M21.5 13 19 7c-.7-1.3-1.5-2-3.2-2"/></svg>;
        const BookOpen = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>;
        const X = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>;
        
        // New Icons for new roles
        const ChefHat = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M6 13.87A4 4 0 0 1 7.41 6a5.11 5.11 0 0 1 1.05-1.54 5 5 0 0 1 7.08 0A5.11 5.11 0 0 1 16.59 6 4 4 0 0 1 18 13.87V21H6Z"/><line x1="6" y1="17" x2="18" y2="17"/></svg>;
        const Trophy = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>;
        const Cloud = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M17.5 19c0-1.7-1.3-3-3-3-.4 0-.7.1-1 .3-.3-1.6-1.7-2.8-3.5-2.8-1.5 0-2.8.8-3.5 2h-.5c-1.7 0-3 1.3-3 3s1.3 3 3 3h11.5c1.7 0 3-1.3 3-3z"/></svg>;
        const Bone = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M17 10c.7-.7 1.69 0 2.5 0a2.5 2.5 0 1 0 0-5 .5.5 0 0 1-.5-.5 2.5 2.5 0 1 0-5 0c0 .81.7 1.8 0 2.5l-7 7c-.7.7-1.69 0-2.5 0a2.5 2.5 0 0 0 0 5c.28 0 .5.22.5.5a2.5 2.5 0 1 0 5 0c0-.81-.7-1.8 0-2.5Z"/></svg>;
        const Hand = (props) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>;

        // --- GAME DATA & CONSTANTS ---

        const BOARD_SIZE = 29; 
        const GRID_COLS = 5; 
        const GRID_ROWS = 6;

        const COLORS = [
          { name: 'Red', bg: 'bg-red-500', text: 'text-red-700', border: 'border-red-600', ring: 'ring-red-300', icon: 'ü¶É' },
          { name: 'Blue', bg: 'bg-blue-500', text: 'text-blue-700', border: 'border-blue-600', ring: 'ring-blue-300', icon: 'üèà' },
          { name: 'Green', bg: 'bg-green-500', text: 'text-green-700', border: 'border-green-600', ring: 'ring-green-300', icon: 'ü•ß' },
          { name: 'Yellow', bg: 'bg-yellow-500', text: 'text-yellow-700', border: 'border-yellow-600', ring: 'ring-yellow-300', icon: 'üé©' },
          { name: 'Purple', bg: 'bg-purple-500', text: 'text-purple-700', border: 'border-purple-600', ring: 'ring-purple-300', icon: 'üçá' },
          { name: 'Orange', bg: 'bg-orange-500', text: 'text-orange-700', border: 'border-orange-600', ring: 'ring-orange-300', icon: 'üåΩ' },
          { name: 'Pink', bg: 'bg-pink-500', text: 'text-pink-700', border: 'border-pink-600', ring: 'ring-pink-300', icon: 'üç∑' },
          { name: 'Teal', bg: 'bg-teal-500', text: 'text-teal-700', border: 'border-teal-600', ring: 'ring-teal-300', icon: 'üçÇ' },
        ];

        const ROLES = {
          COUSIN: { id: 'cousin', name: 'Cool Cousin', desc: 'Starts with "Cool Shades".', icon: <Glasses className="w-4 h-4" /> },
          GLUTTON: { id: 'glutton', name: 'The Glutton', desc: 'Immune to "Skip Turn".', icon: <Pizza className="w-4 h-4" /> },
          TATTLE: { id: 'tattle', name: 'The Tattletale', desc: 'Moves forward if others cheat.', icon: <Megaphone className="w-4 h-4" /> },
          FAV: { id: 'fav', name: 'Grandma\'s Fav', desc: 'Starts with a Shield.', icon: <Crown className="w-4 h-4" /> },
          CHEF: { id: 'chef', name: 'The Chef', desc: 'Immune to Burnt Rolls/Food Cards.', icon: <ChefHat className="w-4 h-4" /> },
          FAN: { id: 'fan', name: 'Football Fan', desc: 'Double bonus from Touchdowns.', icon: <Trophy className="w-4 h-4" /> },
          SHEEP: { id: 'sheep', name: 'Black Sheep', desc: 'Your attacks push back extra.', icon: <Cloud className="w-4 h-4" /> },
          DOG: { id: 'dog', name: 'The Dog', desc: 'A literal dog. Starts with Bone (Shield).', icon: <Bone className="w-4 h-4" /> },
        };

        const SPECIAL_TILES = {
          3: { icon: 'ü•î', label: 'Mashed', desc: 'Stuck in potatoes! Go back 1.' },
          7: { icon: 'üç∑', label: 'Cheers', desc: 'A toast! Nothing happens.' },
          12: { icon: 'üò¥', label: 'Nap Time', desc: 'Tryptophan hit! Skip next turn.' },
          18: { icon: 'üèà', label: 'Touchdown', desc: 'Score! Move forward 2 spaces.' },
          24: { icon: 'ü¶¥', label: 'Wishbone', desc: 'Good luck! Roll two d4s next turn.' },
          28: { icon: 'ü•ß', label: 'Dessert', desc: 'Almost there!' },
        };

        const OFFENSIVE_DECK = [
          { id: 'o1', title: 'Uncle Jeff\'s Politics', desc: 'He brought up the election. Again.', effect: 'skip_turn', value: 1, flavor: 'Hide in the garage with Uncle Charlie.' },
          { id: 'o2', title: 'Burnt Rolls', desc: 'Aunt Claudia forgot the timer!', effect: 'move_back', value: 3, flavor: 'Go back 3 spaces to buy more.' },
          { id: 'o3', title: 'Kids Table Exile', desc: 'Aunt Anna said there\'s no room for you.', effect: 'move_back', value: 5, flavor: 'Retreat 5 spaces to the folding chairs.' },
          { id: 'o4', title: 'Grandma Ann\'s Guilt', desc: 'She asked why you never call.', effect: 'move_back', value: 2, flavor: 'Move back 2 spaces from emotional damage.' },
          { id: 'o5', title: 'Uncle Rob\'s Prank', desc: 'He put hot sauce in your pie.', effect: 'swap', value: 0, flavor: 'Swap places with someone while running for water!' },
          { id: 'o6', title: 'Uncle Roger\'s Story', desc: 'It\'s the one about the fishing trip. It never ends.', effect: 'skip_turn', value: 1, flavor: 'Skip a turn falling asleep.' },
          { id: 'o7', title: 'Spilled Gravy', desc: 'Uncle Joe bumped the table!', effect: 'move_back', value: 4, flavor: 'Go back 4 spaces to clean it up.' },
          { id: 'o8', title: 'Black Friday Plan', desc: 'Aunt Theresa is dragging you shopping at 3 AM.', effect: 'skip_turn', value: 1, flavor: 'Skip turn waiting in line.' },
        ];

        const DEFENSIVE_DECK = [
          { id: 'd1', title: 'Grandpa Prebeg\'s Wisdom', desc: 'He slipped you a $20 bill.', effect: 'move_forward', value: 3, flavor: 'Move forward 3 spaces quietly.' },
          { id: 'd2', title: 'Aunt Rosie\'s Hug', desc: 'She blocked the haters for you.', effect: 'shield', value: 1, flavor: 'Block the next Offensive card.' },
          { id: 'd3', title: 'Uncle Guy\'s Joke', desc: 'It was actually funny!', effect: 'move_forward', value: 2, flavor: 'Laughing moves you forward 2 spaces.' },
          { id: 'd4', title: 'The Wishbone', desc: 'You beat Uncle Charlie!', effect: 'double_roll', value: 0, flavor: 'Roll two d4s next turn.' },
          { id: 'd5', title: 'Hidden Sandwich', desc: 'The Moistmaker!', effect: 'shield', value: 1, flavor: 'Immune to next bad effect.' },
          { id: 'd6', title: 'Football Nap', desc: 'Sleeping through the drama.', effect: 'move_forward', value: 2, flavor: 'Refreshed! Move 2 spaces.' },
          { id: 'd7', title: 'Secret Wine Stash', desc: 'Found in the pantry.', effect: 'move_forward', value: 4, flavor: 'Liquid courage! Move 4 spaces.' },
        ];

        const COOL_SHADES_CARD = { id: 'special_cc', title: 'Cool Shades', desc: 'Whatever, man. Nothing bothers you.', effect: 'shield', value: 1, flavor: 'Role Ability: Immune to next bad effect.' };

        const GAME_PHASES = {
          SETUP_COUNT: 'SETUP_COUNT',
          SETUP_NAMES: 'SETUP_NAMES',
          START_TURN: 'START_TURN',
          ROLLING: 'ROLLING',
          MOVING: 'MOVING',
          BATTLE: 'BATTLE', 
          EVENT_TRIGGER: 'EVENT_TRIGGER', 
          DRAW_CHOICE: 'DRAW_CHOICE',
          TURN_TRANSITION: 'TURN_TRANSITION',
          GAME_OVER: 'GAME_OVER',
        };

        const playSound = (type) => {
            SoundEngine.play(type);
        };

        // --- COMPONENTS ---

        const Confetti = () => {
          const [particles, setParticles] = useState([]);
          useEffect(() => {
            const colors = ['#fcd34d', '#ef4444', '#3b82f6', '#10b981', '#f97316'];
            const count = 100;
            const newParticles = Array.from({ length: count }).map((_, i) => ({
              id: i,
              x: Math.random() * 100,
              y: -10,
              color: colors[Math.floor(Math.random() * colors.length)],
              delay: Math.random() * 2,
              duration: 3 + Math.random() * 2,
              rotation: Math.random() * 360,
            }));
            setParticles(newParticles);
          }, []);
          return (
            <div className="fixed inset-0 pointer-events-none z-[60] overflow-hidden">
              {particles.map(p => (
                <div key={p.id} className="absolute w-3 h-3 rounded-sm" style={{ left: `${p.x}%`, top: `-20px`, backgroundColor: p.color, animation: `fall ${p.duration}s linear ${p.delay}s infinite`, transform: `rotate(${p.rotation}deg)` }} />
              ))}
              <style jsx>{` @keyframes fall { to { transform: translateY(110vh) rotate(720deg); } } `}</style>
            </div>
          );
        };

        const Card = ({ card, onClick, isSelected }) => (
          <div onClick={onClick} className={`relative w-36 h-52 rounded-xl shadow-lg p-3 flex flex-col justify-between cursor-pointer transition-all transform duration-200 shrink-0 ${isSelected ? 'ring-4 ring-yellow-400 scale-105 z-10 -translate-y-4' : 'hover:scale-105 hover:-translate-y-2'} ${OFFENSIVE_DECK.some(c => c.id === card.id) ? 'bg-gradient-to-br from-red-50 to-red-100 border-2 border-red-800' : card.id === 'special_cc' ? 'bg-gradient-to-br from-purple-50 to-purple-100 border-2 border-purple-800' : 'bg-gradient-to-br from-blue-50 to-blue-100 border-2 border-blue-800'}`}>
            <div className={`text-xs font-black text-center uppercase tracking-widest mb-2 border-b-2 pb-1 ${OFFENSIVE_DECK.some(c => c.id === card.id) ? 'border-red-200 text-red-900' : card.id === 'special_cc' ? 'border-purple-200 text-purple-900' : 'border-blue-200 text-blue-900'}`}>{OFFENSIVE_DECK.some(c => c.id === card.id) ? '‚öîÔ∏è Offense' : card.id === 'special_cc' ? 'üòé Ability' : 'üõ°Ô∏è Defense'}</div>
            <div className="text-sm font-extrabold leading-tight text-center text-gray-800">{card.title}</div>
            <div className="text-[11px] text-gray-600 text-center italic my-2 leading-tight">{card.desc}</div>
            <div className={`mt-auto text-[10px] font-bold text-center rounded p-1.5 shadow-sm ${OFFENSIVE_DECK.some(c => c.id === card.id) ? 'bg-red-200 text-red-900' : card.id === 'special_cc' ? 'bg-purple-200 text-purple-900' : 'bg-blue-200 text-blue-900'}`}>{card.flavor}</div>
          </div>
        );

        const PlayerToken = ({ player, isActive }) => (
          <div className={`w-8 h-8 md:w-10 md:h-10 rounded-full flex items-center justify-center text-lg md:text-2xl shadow-lg border-2 relative transition-all duration-300 z-10 bg-white ${player.color.border} ${isActive ? 'ring-4 ring-white ring-offset-2 ring-offset-amber-200 scale-110 z-20' : ''}`} title={`${player.name} (${player.role.name})`}>
            {player.icon}
            {player.shield && (<div className="absolute -top-3 -right-3 bg-blue-600 text-white rounded-full p-0.5 w-5 h-5 flex items-center justify-center text-[10px] shadow border border-white">üõ°Ô∏è</div>)}
          </div>
        );

        function PrebegSpanksGiving() {
          const [phase, setPhase] = useState(GAME_PHASES.SETUP_COUNT);
          const [playerCount, setPlayerCount] = useState(2);
          const [playerNames, setPlayerNames] = useState(Array(8).fill('')); 
          const [playerRoles, setPlayerRoles] = useState(Array(8).fill('cousin')); 
          const [players, setPlayers] = useState([]);
          const [currentPlayerIdx, setCurrentPlayerIdx] = useState(0);
          const [diceVal, setDiceVal] = useState(null);
          const [logs, setLogs] = useState(["Welcome to Prebeg Spanks-Giving!"]);
          const [selectedCard, setSelectedCard] = useState(null);
          const [targetMode, setTargetMode] = useState(false);
          const [showRules, setShowRules] = useState(false);
          const [showIntroVideo, setShowIntroVideo] = useState(true);
          const [activeEvent, setActiveEvent] = useState(null); 
          const [battleState, setBattleState] = useState(null); 
          const [showRiggedModal, setShowRiggedModal] = useState(false);

          const logEndRef = useRef(null);
          const addLog = (msg) => setLogs(prev => [...prev, msg]);
          useEffect(() => { logEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [logs]);

          const initNameSetup = (count) => {
            playSound('click');
            setPlayerCount(count);
            const defaults = Array.from({ length: count }).map((_, i) => `Player ${i + 1}`);
            setPlayerNames(prev => {
                const newNames = [...prev];
                defaults.forEach((name, i) => newNames[i] = name);
                return newNames;
            });
            const roleKeys = Object.keys(ROLES);
            setPlayerRoles(Array.from({ length: count }).map((_, i) => roleKeys[i % roleKeys.length].toLowerCase()));
            setPhase(GAME_PHASES.SETUP_NAMES);
          };

          const finalizeSetup = () => {
            playSound('success');
            const newPlayers = Array.from({ length: playerCount }).map((_, i) => {
              let roleKey = Object.keys(ROLES).find(key => ROLES[key].id === playerRoles[i]);
              if (!roleKey) roleKey = Object.keys(ROLES)[0];
              
              const roleData = ROLES[roleKey];
              const p = {
                id: i,
                name: playerNames[i].trim() || `Player ${i + 1}`,
                color: COLORS[i],
                icon: COLORS[i].icon,
                role: roleData,
                pos: 0,
                cards: [],
                shield: false,
                skipTurn: false,
                doubleRoll: false,
                usedRigged: false, // New Property
              };
              if (roleData.id === 'fav' || roleData.id === 'dog') p.shield = true;
              if (roleData.id === 'cousin') p.cards.push(COOL_SHADES_CARD);
              return p;
            });
            setPlayers(newPlayers);
            setPhase(GAME_PHASES.START_TURN);
            addLog("ü¶É The Turkey is in the oven! Game Start!");
            addLog(`üëâ ${newPlayers[0].name}'s turn begins.`);
          };

          const rollDice = () => {
            playSound('roll');
            const player = players[currentPlayerIdx];
            let rolls = 0;
            const interval = setInterval(() => {
              setDiceVal(Math.floor(Math.random() * 4) + 1);
              rolls++;
              if (rolls > 10) {
                clearInterval(interval);
                finalizeRoll(player);
              }
            }, 50);
          };

          const finalizeRoll = (player) => {
            let roll = Math.floor(Math.random() * 4) + 1;
            let msg = `${player.name} rolled a ${roll}!`;
            if (player.doubleRoll) {
              const roll2 = Math.floor(Math.random() * 4) + 1;
              roll += roll2;
              msg = `${player.name} used Wishbone! Rolled ${roll - roll2} + ${roll2} for a total of ${roll}!`;
              const updated = [...players];
              updated[currentPlayerIdx].doubleRoll = false;
              setPlayers(updated);
            }
            setDiceVal(roll);
            addLog(msg);
            setTimeout(() => { animateMovement(currentPlayerIdx, roll); }, 500);
          };

          const handleCheat = () => {
            if (phase !== GAME_PHASES.START_TURN) return;
            playSound('click');
            const isSuccess = Math.random() > 0.8; 
            const player = players[currentPlayerIdx];
            if (isSuccess) {
              playSound('success');
              addLog(`üïµÔ∏è‚Äç‚ôÇÔ∏è ${player.name} cheated successfully! +5 spaces!`);
              animateMovement(currentPlayerIdx, 5);
            } else {
              playSound('fail');
              addLog(`üëÄ CAUGHT! Grandma sent ${player.name} back 5 spaces!`);
              const tattleTales = players.filter(p => p.id !== player.id && p.role.id === 'tattle');
              let bonusAnimations = [];
              if (tattleTales.length > 0) {
                tattleTales.forEach(tt => {
                   addLog(`üì¢ ${tt.name} (Tattletale) moves forward 3 spaces!`);
                   bonusAnimations.push(tt.id);
                });
              }
              animateMovement(currentPlayerIdx, -5, () => {
                 if (bonusAnimations.length > 0) {
                   setPlayers(prev => {
                     const copy = [...prev];
                     bonusAnimations.forEach(id => { copy[id].pos = Math.min(BOARD_SIZE, copy[id].pos + 3); });
                     return copy;
                   });
                   playSound('success');
                 }
                 setTimeout(endTurn, 1500);
              });
            }
          };

          // RIGGED BUTTON LOGIC
          const handleRiggedClick = () => {
              playSound('fail'); 
              setShowRiggedModal(true);
          };

          const resolveRigged = (pity) => {
              const newPlayers = [...players];
              const player = newPlayers[currentPlayerIdx];
              player.usedRigged = true;
              
              if (pity) {
                  playSound('success');
                  player.pos = Math.min(BOARD_SIZE, player.pos + 3);
                  addLog(`üçº The family took pity on baby ${player.name}. +3 Spaces.`);
              } else {
                  playSound('fail');
                  addLog(`‚ùÑÔ∏è No sympathy for ${player.name}. The family laughs.`);
              }
              setPlayers(newPlayers);
              setShowRiggedModal(false);
          };

          const animateMovement = (pIdx, steps, onComplete = null) => {
            setPhase(GAME_PHASES.MOVING);
            let stepsRemaining = Math.abs(steps);
            const direction = steps > 0 ? 1 : -1;
            const moveInterval = setInterval(() => {
              setPlayers(prevPlayers => {
                const newPlayers = [...prevPlayers];
                let nextPos = newPlayers[pIdx].pos + direction;
                if (nextPos > BOARD_SIZE) nextPos = BOARD_SIZE;
                if (nextPos < 0) nextPos = 0;
                newPlayers[pIdx].pos = nextPos;
                return newPlayers;
              });
              playSound('step');
              stepsRemaining--;
              if (stepsRemaining <= 0) {
                clearInterval(moveInterval);
                setTimeout(() => {
                  if (onComplete) onComplete();
                  else handleMovementEnd(pIdx);
                }, 300);
              }
            }, 300);
          };

          const handleMovementEnd = (pIdx) => {
            const player = players[pIdx]; 
            const finalPos = player.pos;
            if (finalPos >= BOARD_SIZE) {
              setPhase(GAME_PHASES.GAME_OVER);
              playSound('win');
              addLog(`üèÜ ${player.name} REACHED THE END! VICTORY! üèÜ`);
              return;
            }
            if (finalPos > 0 && finalPos < BOARD_SIZE) {
              const defenders = players.filter(p => p.id !== player.id && p.pos === finalPos);
              if (defenders.length > 0) {
                startBattle(player, defenders[0]);
                return;
              }
            }
            checkTileEffect(pIdx);
          };

          // --- NEW FUNCTION: TILE EFFECTS ---
          const checkTileEffect = (pIdx) => {
             const player = players[pIdx];
             const tile = SPECIAL_TILES[player.pos];
             
             if (tile) {
                const newPlayers = [...players];
                const active = newPlayers[pIdx];

                if (tile.label === 'Nap Time') {
                    addLog(`üò¥ ${active.name} lands on Nap Time. Skip next turn!`);
                    playSound('fail');
                    active.skipTurn = true;
                    setPlayers(newPlayers);
                } else if (tile.label === 'Touchdown') {
                    const bonus = active.role.id === 'fan' ? 4 : 2;
                    addLog(`üèà TOUCHDOWN! ${active.name} moves forward ${bonus} spaces!`);
                    playSound('success');
                    active.pos = Math.min(BOARD_SIZE, active.pos + bonus);
                    setPlayers(newPlayers);
                } else if (tile.label === 'Mashed') {
                    addLog(`ü•î ${active.name} got stuck in mashed potatoes. Back 1 space.`);
                    playSound('fail');
                    active.pos = Math.max(0, active.pos - 1);
                    setPlayers(newPlayers);
                } else if (tile.label === 'Wishbone') {
                    addLog(`ü¶¥ ${active.name} found the Wishbone! Double roll next turn.`);
                    playSound('shield');
                    active.doubleRoll = true;
                    setPlayers(newPlayers);
                }
             }
             
             // Continue to Post Move logic
             setTimeout(() => {
                checkPostMove(pIdx);
             }, 800);
          };

          const checkPostMove = (pIdx) => {
            const rollEvent = Math.random();
            if (rollEvent < 0.25) { 
              triggerRandomEvent(players[pIdx]);
            } else {
              setPhase(GAME_PHASES.DRAW_CHOICE);
            }
          };

          const startBattle = (attacker, defender) => {
            playSound('alert');
            setBattleState({ attacker, defender, step: 'INTRO', p1Choice: null, p2Choice: null, winner: null });
            setPhase(GAME_PHASES.BATTLE);
            addLog(`‚öîÔ∏è BATTLE! ${attacker.name} landed on ${defender.name}!`);
          };

          const handleBattleChoice = (choice) => {
            playSound('click');
            const { step, p1Choice } = battleState;
            if (step === 'P1') {
              setBattleState(prev => ({ ...prev, p1Choice: choice, step: 'SWITCH' }));
            } else if (step === 'P2') {
              resolveBattle(p1Choice, choice);
            }
          };

          const resolveBattle = (c1, c2) => {
            let winnerId = null;
            if (c1 === c2) winnerId = 'tie';
            else if ((c1 === 'rock' && c2 === 'scissors') || (c1 === 'paper' && c2 === 'rock') || (c1 === 'scissors' && c2 === 'paper')) {
              winnerId = battleState.attacker.id;
            } else {
              winnerId = battleState.defender.id;
            }
            setBattleState(prev => ({ ...prev, p2Choice: c2, step: 'RESULT', winner: winnerId }));
            if (winnerId && winnerId !== 'tie') playSound('win');
            else playSound('fail');
          };

          const finalizeBattle = () => {
            const { winner, attacker, defender } = battleState;
            if (winner === 'tie') {
              addLog("ü§ù It was a tie! Rematch!");
              setBattleState(prev => ({ ...prev, step: 'P1', p1Choice: null, p2Choice: null, winner: null }));
            } else {
              const loserId = winner === attacker.id ? defender.id : attacker.id;
              const winnerName = winner === attacker.id ? attacker.name : defender.name;
              const loserName = winner === attacker.id ? defender.name : attacker.name;
              addLog(`üèÜ ${winnerName} won! ${loserName} pushed back.`);
              const newPlayers = [...players];
              const loserIdx = newPlayers.findIndex(p => p.id === loserId);
              newPlayers[loserIdx].pos = Math.max(0, newPlayers[loserIdx].pos - 1);
              setPlayers(newPlayers);
              setBattleState(null);
              // Winner logic check
              checkTileEffect(currentPlayerIdx);
            }
          };

          const triggerRandomEvent = (player) => {
            playSound('alert');
            const isGood = Math.random() > 0.5;
            if (isGood) {
              setActiveEvent({
                type: 'saint', title: 'The Saint, Uncle Mike', desc: 'Uncle Mike showed up with extra stuffing!',
                effect: () => {
                  const newPlayers = [...players];
                  const idx = newPlayers.findIndex(p => p.id === player.id);
                  newPlayers[idx].pos = Math.min(BOARD_SIZE, newPlayers[idx].pos + 3);
                  addLog(`üòá Uncle Mike moved ${player.name} forward 3 spaces!`);
                  setPlayers(newPlayers);
                }
              });
            } else {
              setActiveEvent({
                type: 'bad', title: 'Bad Marty', desc: 'Bad Marty touched the TV remote!',
                effect: () => {
                  const newPlayers = [...players];
                  const idx = newPlayers.findIndex(p => p.id === player.id);
                  newPlayers[idx].pos = Math.max(0, newPlayers[idx].pos - 3);
                  addLog(`üòà Bad Marty pushed ${player.name} back 3 spaces!`);
                  setPlayers(newPlayers);
                }
              });
            }
            setPhase(GAME_PHASES.EVENT_TRIGGER);
          };

          const resolveEvent = () => {
            activeEvent.effect();
            setActiveEvent(null);
            setPhase(GAME_PHASES.DRAW_CHOICE);
          };

          const drawCard = (type) => {
            playSound('click');
            const deck = type === 'offense' ? OFFENSIVE_DECK : DEFENSIVE_DECK;
            const randomCard = deck[Math.floor(Math.random() * deck.length)];
            const newPlayers = [...players];
            newPlayers[currentPlayerIdx].cards.push(randomCard);
            setPlayers(newPlayers);
            addLog(`${newPlayers[currentPlayerIdx].name} drew a card.`);
            endTurn();
          };

          const playCard = (cardIndex) => {
            playSound('click');
            setSelectedCard({ ...players[currentPlayerIdx].cards[cardIndex], index: cardIndex });
            setTargetMode(true);
          };

          const executeCardEffect = (targetId) => {
            const sourcePlayer = players[currentPlayerIdx];
            const card = selectedCard;
            const newPlayers = [...players];
            const target = newPlayers[targetId];
            let blocked = false;

            if (targetId !== currentPlayerIdx && target.shield && (OFFENSIVE_DECK.some(c => c.id === card.id))) {
              blocked = true;
              target.shield = false; 
              addLog(`üõ°Ô∏è ${target.name} blocked ${sourcePlayer.name}'s ${card.title}!`);
              playSound('shield');
            }

            if (!blocked) {
              if (card.effect === 'skip_turn' && target.role.id === 'glutton') {
                addLog(`üçó ${target.name} (The Glutton) is immune to Skip Turn!`);
                playSound('fail');
              } else if (card.id === 'o2' && target.role.id === 'chef') {
                addLog(`üë®‚Äçüç≥ ${target.name} (The Chef) fixed the Burnt Rolls! Immune.`);
                playSound('fail');
              } else {
                addLog(`üÉè ${sourcePlayer.name} played "${card.title}" on ${target.name}.`);
                playSound('success');
                switch (card.effect) {
                  case 'move_forward': target.pos = Math.min(BOARD_SIZE, target.pos + card.value); addLog(`${target.name} moved forward ${card.value} spaces.`); break;
                  case 'move_back': 
                    let val = card.value;
                    if (sourcePlayer.role.id === 'sheep') { val += 1; addLog(`üêë Black Sheep bonus push! (+1)`); }
                    target.pos = Math.max(0, target.pos - val); 
                    addLog(`${target.name} was pushed back ${val} spaces.`); 
                    break;
                  case 'skip_turn': target.skipTurn = true; addLog(`${target.name} will skip their next turn.`); break;
                  case 'shield': target.shield = true; addLog(`${target.name} is now shielded.`); break;
                  case 'double_roll': target.doubleRoll = true; addLog(`${target.name} will roll double next turn.`); break;
                  case 'swap': 
                    const tempPos = sourcePlayer.pos;
                    newPlayers[currentPlayerIdx].pos = target.pos;
                    newPlayers[targetId].pos = tempPos;
                    addLog(`${sourcePlayer.name} swapped places with ${target.name}!`);
                    break;
                }
              }
            }
            newPlayers[currentPlayerIdx].cards.splice(card.index, 1);
            setPlayers(newPlayers);
            setTargetMode(false);
            setSelectedCard(null);
          };

          const endTurn = () => {
            let nextIdx = (currentPlayerIdx + 1) % players.length;
            let checks = 0;
            // Handle skipping turns logic
            while (players[nextIdx].skipTurn && checks < players.length) {
              addLog(`üí§ ${players[nextIdx].name} is sleeping off the turkey (Skipped).`);
              const newPlayers = [...players];
              newPlayers[nextIdx].skipTurn = false;
              setPlayers(newPlayers);
              nextIdx = (nextIdx + 1) % players.length;
              checks++;
            }
            setCurrentPlayerIdx(nextIdx);
            setPhase(GAME_PHASES.TURN_TRANSITION); // New Interstitial Phase
          };

          const startNextTurn = () => {
             playSound('success');
             setPhase(GAME_PHASES.START_TURN);
             addLog(`üëâ It is now ${players[currentPlayerIdx].name}'s turn.`);
             setDiceVal(null);
          };

          const getPathD = () => {
            let path = `M `; 
            for (let i = 0; i <= BOARD_SIZE; i++) {
               let row = Math.floor(i / GRID_COLS);
               let col = (row % 2 === 0) ? i % GRID_COLS : (GRID_COLS - 1) - (i % GRID_COLS);
               const x = 10 + (col * 20);
               const y = 8.33 + (row * (100/GRID_ROWS));
               path += `${x} ${y}`;
               if (i < BOARD_SIZE) path += " L ";
            }
            return path;
          };

          const renderBoard = () => {
            const gridCells = [];
            for (let r = 0; r < GRID_ROWS; r++) {
               for (let c = 0; c < GRID_COLS; c++) {
                  const visualIndex = r * GRID_COLS + c;
                  let logicalIndex = (r % 2 === 0) ? r * GRID_COLS + c : r * GRID_COLS + (GRID_COLS - 1 - c);
                  if (logicalIndex > BOARD_SIZE) { gridCells.push(<div key={visualIndex}></div>); continue; }

                  const occupants = players.filter(p => p.pos === logicalIndex);
                  const isStart = logicalIndex === 0;
                  const isEnd = logicalIndex === BOARD_SIZE;
                  const special = SPECIAL_TILES[logicalIndex];

                  let tileStyle = 'bg-white border-gray-300'; 
                  let content = <span className="absolute top-1 left-2 text-[10px] md:text-xs font-bold text-gray-400">{logicalIndex}</span>;

                  if (isStart) {
                    tileStyle = 'bg-amber-100 border-amber-400 ring-4 ring-amber-200';
                    content = <span className="text-[10px] font-black text-amber-900 uppercase tracking-wider">Start</span>;
                  } else if (isEnd) {
                    tileStyle = 'bg-orange-600 border-orange-800 ring-4 ring-orange-400 text-white';
                    content = <div className="flex flex-col items-center"><Drumstick className="w-5 h-5 md:w-8 md:h-8 animate-pulse" /><span className="text-[9px] font-black uppercase">Feast!</span></div>;
                  } else if (special) {
                    tileStyle = 'bg-amber-50 border-amber-200';
                    content = <><span className="absolute top-1 left-2 text-[10px] md:text-xs font-bold text-amber-800/50">{logicalIndex}</span><div className="flex flex-col items-center opacity-80 mt-1"><span className="text-lg md:text-2xl">{special.icon}</span><span className="text-[8px] md:text-[9px] font-bold text-amber-900 leading-none uppercase">{special.label}</span></div></>;
                  }

                  gridCells.push(
                    <div key={visualIndex} className={`relative w-full aspect-square rounded-full flex flex-col items-center justify-center shadow-md transition-all z-10 border-4 ${tileStyle} ${isEnd ? 'shadow-orange-500/50' : 'shadow-black/10'}`}>
                      {content}
                      <div className="absolute inset-0 flex flex-wrap justify-center items-center gap-0.5 p-1 pointer-events-none z-10">
                        {occupants.map((p, i) => (
                          <div key={p.id} className="absolute transition-all duration-500" style={{ left: '50%', top: '50%', transform: `translate(-50%, -50%) translate(${(i%2)*10}px, ${Math.floor(i/2)*-10}px)`, zIndex: 20+i }}>
                              <PlayerToken player={p} isActive={currentPlayerIdx === p.id} />
                          </div>
                        ))}
                      </div>
                    </div>
                  );
               }
            }
            return gridCells;
          };

          const minPos = players.length > 0 ? Math.min(...players.map(p => p.pos)) : 0;
          const isLastPlace = players.length > 0 && players[currentPlayerIdx].pos === minPos; 
          const canUseRigged = phase === GAME_PHASES.START_TURN && isLastPlace && !players[currentPlayerIdx].usedRigged;

          return (
            <div className="min-h-screen bg-orange-50 font-sans text-gray-900 select-none pb-20">
              {phase === GAME_PHASES.GAME_OVER && <Confetti />}
              
              {/* INTRO VIDEO */}
              {showIntroVideo && (
                <div className="fixed inset-0 bg-black/90 z-[100] flex flex-col items-center justify-center p-4">
                  <div className="w-full max-w-3xl aspect-video bg-black shadow-2xl rounded-xl overflow-hidden border-4 border-amber-500 relative">
                     <iframe width="100%" height="100%" src="https://www.youtube.com/embed/NtMmpMSfA5I?autoplay=1" title="Prebeg Spanks-Giving Intro" frameBorder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowFullScreen></iframe>
                  </div>
                  <button onClick={() => { setShowIntroVideo(false); SoundEngine.init(); }} className="mt-8 bg-gradient-to-r from-red-600 to-orange-600 text-white font-black text-2xl py-4 px-12 rounded-full shadow-lg hover:scale-105 transition-transform flex items-center gap-2">üçó LET'S FEAST! (Skip Video)</button>
                </div>
              )}

              {/* RIGGED MODAL */}
              {showRiggedModal && (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-[60] flex items-center justify-center p-4">
                    <div className="bg-pink-100 rounded-3xl p-8 max-w-lg w-full shadow-2xl border-8 border-pink-400 text-center animate-in zoom-in relative">
                         <div className="absolute -top-10 left-1/2 -translate-x-1/2 text-8xl">üë∂</div>
                         <h2 className="text-3xl font-black text-pink-600 mt-8 mb-4">Awww, is {players[currentPlayerIdx].name} sad?</h2>
                         <p className="text-xl font-bold text-gray-700 mb-6">"This game is rigged! It's not fair! I hate you all!"</p>
                         <div className="bg-white p-4 rounded-xl border-2 border-pink-200 mb-6">
                            <p className="text-sm font-bold text-gray-500 uppercase mb-2">To the rest of the family:</p>
                            <p className="text-lg font-bold text-gray-800">Do we give this big baby some sympathy points?</p>
                         </div>
                         <div className="grid grid-cols-2 gap-4">
                            <button onClick={() => resolveRigged(true)} className="bg-green-500 text-white py-4 rounded-xl font-black text-lg shadow hover:scale-105 transition-transform">Yes (Pity +3)</button>
                            <button onClick={() => resolveRigged(false)} className="bg-red-600 text-white py-4 rounded-xl font-black text-lg shadow hover:scale-105 transition-transform">NO! (Suffer)</button>
                         </div>
                    </div>
                </div>
              )}

              {/* TURN TRANSITION / CURTAIN */}
              {phase === GAME_PHASES.TURN_TRANSITION && (
                 <div className="fixed inset-0 bg-orange-900/95 z-50 flex flex-col items-center justify-center p-6 text-center animate-in fade-in">
                    <div className="mb-6"><Hand className="w-24 h-24 text-orange-200 animate-pulse" /></div>
                    <h2 className="text-4xl md:text-6xl font-black text-white mb-2 uppercase tracking-tighter">Pass The Device</h2>
                    <p className="text-xl text-orange-200 mb-8 font-bold">Don't let {players[(currentPlayerIdx + players.length - 1) % players.length].name} see!</p>
                    <div className="bg-white/10 p-6 rounded-2xl backdrop-blur-sm border-2 border-white/20 mb-8">
                       <p className="text-orange-100 text-sm font-bold uppercase mb-2">Next Up</p>
                       <div className="flex items-center justify-center gap-4 text-4xl text-white font-black">
                          <span className="text-6xl">{players[currentPlayerIdx].icon}</span>
                          {players[currentPlayerIdx].name}
                       </div>
                    </div>
                    <button onClick={startNextTurn} className="bg-white text-orange-900 px-12 py-5 rounded-full font-black text-2xl shadow-2xl hover:scale-105 transition-transform flex items-center gap-2">
                        I am {players[currentPlayerIdx].name} <ArrowRight className="w-6 h-6" />
                    </button>
                 </div>
              )}

              <header className="bg-amber-900 text-orange-50 p-4 shadow-lg sticky top-0 z-40 border-b-4 border-amber-700">
                <div className="max-w-5xl mx-auto flex justify-between items-center">
                  <h1 className="text-xl md:text-3xl font-black tracking-wide uppercase flex items-center gap-2">
                    <Drumstick className="w-6 h-6 md:w-8 md:h-8 text-orange-400" /> <span className="hidden md:inline">Prebeg Spanks-Giving</span><span className="md:hidden">Spanks-Giving</span>
                  </h1>
                  {!['SETUP_COUNT', 'SETUP_NAMES'].includes(phase) && (
                    <div className="flex items-center gap-2 text-sm bg-amber-950/50 px-4 py-2 rounded-full border border-amber-800">
                       <span className="hidden md:inline text-amber-200 uppercase text-xs font-bold mr-1">Turn</span>
                       <span className={`flex items-center gap-1 font-bold ${players[currentPlayerIdx].color.text} bg-white px-3 py-1 rounded-full shadow-sm`}>{players[currentPlayerIdx].icon} {players[currentPlayerIdx].name}</span>
                    </div>
                  )}
                </div>
              </header>

              <main className="max-w-6xl mx-auto p-4 flex flex-col gap-6">
                {phase === GAME_PHASES.SETUP_COUNT && (
                  <div className="bg-white p-8 md:p-12 rounded-3xl shadow-2xl text-center max-w-2xl mx-auto mt-6 border-8 border-amber-200 animate-in zoom-in-95 duration-500">
                    <div className="flex justify-center mb-6"><Drumstick className="w-24 h-24 text-orange-500 animate-bounce" /></div>
                    <h1 className="text-4xl md:text-6xl font-black mb-2 text-amber-900 uppercase">Prebeg<br/><span className="text-orange-600">Spanks-Giving</span></h1>
                    <p className="text-sm md:text-md text-amber-700 font-bold mb-10 tracking-widest uppercase">Secure your Legacy!</p>
                    <h2 className="text-xl font-black text-gray-400 mb-4 uppercase tracking-widest">How many are eating?</h2>
                    <div className="flex flex-wrap justify-center gap-4 mb-8">
                      {[2, 3, 4, 5, 6, 7, 8].map(num => (
                        <button key={num} onClick={() => initNameSetup(num)} className="w-16 h-16 rounded-2xl bg-amber-500 text-white font-black text-3xl shadow-xl hover:scale-110 hover:bg-amber-600 transition-all">{num}</button>
                      ))}
                    </div>
                    <button onClick={() => setShowRules(true)} className="flex items-center justify-center gap-2 mx-auto text-gray-400 hover:text-orange-500 font-bold transition-colors mt-8"><BookOpen className="w-5 h-5" /> How to Play</button>
                  </div>
                )}

                {showRules && (
                  <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                    <div className="bg-white rounded-3xl p-8 max-w-lg w-full shadow-2xl border-4 border-amber-200 relative animate-in zoom-in duration-200 max-h-[90vh] overflow-y-auto">
                      <button onClick={() => setShowRules(false)} className="absolute top-4 right-4 p-2 bg-gray-100 rounded-full hover:bg-gray-200"><X className="w-6 h-6 text-gray-500" /></button>
                      <h2 className="text-3xl font-black text-amber-800 mb-6">Game Rules</h2>
                      <div className="space-y-2 text-gray-700 text-sm">
                        <p><strong>Goal:</strong> Reach the Feast (Tile 29) first!</p>
                        <p><strong>Roles:</strong> Everyone has a unique ability. Check your player card.</p>
                        <p><strong>Tiles:</strong> Watch out for Nap Time (Skip) and Mashed Potatoes (Back 1)!</p>
                        <p><strong>Battle:</strong> Land on someone? Rock-Paper-Scissors! Loser moves back.</p>
                      </div>
                      <button onClick={() => setShowRules(false)} className="w-full mt-6 bg-amber-500 text-white font-bold py-3 rounded-xl">Got it!</button>
                    </div>
                  </div>
                )}

                {phase === GAME_PHASES.SETUP_NAMES && (
                  <div className="bg-white p-8 rounded-3xl shadow-xl max-w-2xl mx-auto mt-6 border-4 border-amber-200 animate-in slide-in-from-right-10 duration-300">
                    <h2 className="text-3xl font-black mb-8 text-amber-800 text-center"><Edit2 className="inline w-8 h-8 mr-2"/> Family Setup</h2>
                    <div className="space-y-4 mb-8 max-h-[60vh] overflow-y-auto pr-2">
                      {Array.from({ length: playerCount }).map((_, i) => (
                        <div key={i} className="flex flex-col md:flex-row gap-4 items-center bg-gray-50 p-4 rounded-xl border border-gray-100">
                          <div className={`w-14 h-14 rounded-full flex items-center justify-center text-2xl shadow-lg ${COLORS[i].bg} text-white shrink-0`}>{COLORS[i].icon}</div>
                          <input type="text" maxLength={12} value={playerNames[i]} onChange={(e) => { const n = [...playerNames]; n[i] = e.target.value; setPlayerNames(n); }} placeholder={`Player ${i + 1}`} className="flex-1 border-2 border-gray-200 rounded-xl px-4 py-2 font-bold" />
                          <div className="relative flex-1">
                              <select value={playerRoles[i]} onChange={(e) => { const r = [...playerRoles]; r[i] = e.target.value; setPlayerRoles(r); }} className="w-full border-2 border-gray-200 rounded-xl px-4 py-2 font-bold appearance-none bg-white">
                                {Object.values(ROLES).map(role => (<option key={role.id} value={role.id}>{role.name}</option>))}
                              </select>
                              <ArrowRight className="absolute right-3 top-3 w-4 h-4 text-gray-400 rotate-90 pointer-events-none" />
                          </div>
                        </div>
                      ))}
                    </div>
                    <button onClick={finalizeSetup} className="w-full bg-green-500 text-white font-black py-4 rounded-xl shadow-lg hover:bg-green-600 text-xl">Start the Feast!</button>
                  </div>
                )}

                {!['SETUP_COUNT', 'SETUP_NAMES'].includes(phase) && (
                  <>
                    <div className="bg-amber-100 p-4 rounded-3xl shadow-2xl border-4 border-amber-800/20 relative overflow-hidden">
                       <svg className="absolute inset-0 w-full h-full pointer-events-none z-0" viewBox="0 0 100 100" preserveAspectRatio="none"><path d={getPathD()} fill="none" stroke="#b45309" strokeWidth="1.5" strokeDasharray="2 2" strokeOpacity="0.6" /></svg>
                       <div className="relative z-10 grid grid-cols-5 gap-2 md:gap-4 max-w-2xl mx-auto">{renderBoard()}</div>
                    </div>

                    {battleState && (
                        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                            <div className="bg-white rounded-3xl p-6 md:p-10 max-w-lg w-full text-center border-8 border-red-600 animate-in zoom-in">
                                <Swords className="w-16 h-16 text-red-600 mx-auto mb-4 animate-pulse" />
                                <h2 className="text-4xl font-black text-red-800 mb-6">BATTLE!</h2>
                                {battleState.step === 'INTRO' && (
                                    <>
                                        <p className="text-xl font-bold mb-8">{battleState.attacker.name} vs {battleState.defender.name}</p>
                                        <button onClick={() => setBattleState(prev => ({...prev, step: 'P1'}))} className="bg-red-600 text-white px-8 py-3 rounded-xl font-black text-xl hover:scale-105 transition-transform">Start</button>
                                    </>
                                )}
                                {(battleState.step === 'P1' || battleState.step === 'P2') && (
                                    <>
                                        <h3 className="text-2xl font-bold mb-2">{battleState.step === 'P1' ? battleState.attacker.name : battleState.defender.name}'s Choice</h3>
                                        <div className="flex justify-center gap-4 mt-8">
                                            {['rock', 'paper', 'scissors'].map(c => (
                                                <button key={c} onClick={() => handleBattleChoice(c)} className="w-20 h-20 bg-gray-100 rounded-xl text-4xl hover:bg-red-100 border-4 border-gray-200">{c === 'rock' ? 'ü™®' : c === 'paper' ? 'üìÑ' : '‚úÇÔ∏è'}</button>
                                            ))}
                                        </div>
                                    </>
                                )}
                                {battleState.step === 'SWITCH' && (
                                    <>
                                        <div className="text-6xl mb-4">üôà</div>
                                        <h3 className="text-2xl font-bold mb-4">Pass Device!</h3>
                                        <p className="mb-6">Hand over to {battleState.defender.name}</p>
                                        <button onClick={() => setBattleState(prev => ({...prev, step: 'P2'}))} className="bg-blue-600 text-white px-8 py-3 rounded-xl font-bold">Ready</button>
                                    </>
                                )}
                                {battleState.step === 'RESULT' && (
                                    <>
                                        <div className="flex justify-center gap-8 mb-6 text-4xl">
                                            <div>{battleState.p1Choice === 'rock' ? 'ü™®' : battleState.p1Choice === 'paper' ? 'üìÑ' : '‚úÇÔ∏è'}</div>
                                            <div>VS</div>
                                            <div>{battleState.p2Choice === 'rock' ? 'ü™®' : battleState.p2Choice === 'paper' ? 'üìÑ' : '‚úÇÔ∏è'}</div>
                                        </div>
                                        <h3 className="text-2xl font-black mb-6">{battleState.winner === 'tie' ? 'TIE!' : `${battleState.winner === battleState.attacker.id ? battleState.attacker.name : battleState.defender.name} WINS!`}</h3>
                                        <button onClick={finalizeBattle} className="bg-gray-900 text-white px-8 py-3 rounded-xl font-bold">Continue</button>
                                    </>
                                )}
                            </div>
                        </div>
                    )}

                    {targetMode && (
                       <div className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex items-center justify-center p-4">
                         <div className="bg-white rounded-2xl p-6 max-w-md w-full shadow-2xl animate-in zoom-in duration-200 border-4 border-amber-400">
                           <h3 className="text-xl font-black text-center mb-6 text-gray-800">Use <span className="text-amber-600">"{selectedCard.title}"</span> on?</h3>
                           <div className="grid grid-cols-2 gap-4 max-h-[50vh] overflow-y-auto p-2">
                             {players.map(p => (
                               <button key={p.id} onClick={() => executeCardEffect(p.id)} className={`p-4 rounded-xl border-2 transition-all ${p.color.border} ${p.color.bg} bg-opacity-10 hover:bg-opacity-30 flex flex-col items-center justify-center gap-2 font-bold`}>
                                 <span className="text-3xl">{p.icon}</span> <span>{p.name}</span>
                               </button>
                             ))}
                           </div>
                           <button onClick={() => { setTargetMode(false); setSelectedCard(null); }} className="mt-6 w-full py-3 text-gray-500 hover:bg-gray-100 rounded-lg font-bold">Cancel</button>
                         </div>
                       </div>
                    )}

                    <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
                      <div className="lg:col-span-5 flex flex-col gap-4">
                        <div className="bg-white p-6 rounded-2xl shadow-lg border border-gray-100 relative overflow-hidden">
                          <div className={`absolute top-0 left-0 w-3 h-full ${players[currentPlayerIdx].color.bg}`}></div>
                          <div className="flex justify-between items-start mb-6 pl-2">
                            <div>
                              <h3 className="font-bold text-gray-400 text-xs uppercase tracking-wider mb-1">Active Player</h3>
                              <div className="text-3xl md:text-4xl font-black text-gray-800 flex items-center gap-3"><span className="text-4xl md:text-5xl">{players[currentPlayerIdx].icon}</span> {players[currentPlayerIdx].name}</div>
                              <div className="flex items-center gap-2 mt-1 text-xs font-bold text-gray-500 bg-gray-100 px-2 py-1 rounded w-fit">{players[currentPlayerIdx].role.icon} {players[currentPlayerIdx].role.name}</div>
                            </div>
                            {players[currentPlayerIdx].shield && (<div className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-xs font-bold flex items-center gap-1 border border-blue-200 animate-pulse"><Shield className="w-3 h-3" /> SHIELD</div>)}
                          </div>

                          <div className="min-h-[160px] flex flex-col justify-center">
                            {phase === GAME_PHASES.START_TURN && (
                                <div className="flex flex-col gap-2">
                                  <div className="flex gap-2">
                                    <button onClick={rollDice} className="flex-1 bg-gradient-to-r from-orange-500 to-red-500 text-white font-black py-5 rounded-xl shadow-lg text-2xl hover:scale-105 transition-transform">üé≤ ROLL D4</button>
                                    <button onClick={handleCheat} className="w-24 bg-gray-100 hover:bg-red-50 text-gray-400 hover:text-red-500 rounded-xl font-bold text-xs flex flex-col items-center justify-center border-2 border-dashed border-gray-300 transition-colors"><Eye className="w-5 h-5 mb-1" />Cheat</button>
                                  </div>
                                  {canUseRigged && (
                                     <button onClick={handleRiggedClick} className="w-full bg-pink-500 text-white font-black py-2 rounded-xl shadow-lg border-b-4 border-pink-700 animate-pulse text-sm hover:bg-pink-600">üò≠ THIS GAME IS RIGGED!</button>
                                  )}
                                </div>
                            )}
                            {(phase === GAME_PHASES.ROLLING || phase === GAME_PHASES.MOVING) && (
                               <div className="flex flex-col items-center justify-center w-full">
                                  <div className="text-9xl font-black text-amber-600 animate-bounce drop-shadow-md">{diceVal !== null ? diceVal : '?'}</div>
                               </div>
                            )}
                            {phase === GAME_PHASES.DRAW_CHOICE && (
                              <div className="grid grid-cols-2 gap-4 animate-in fade-in">
                                <button onClick={() => drawCard('offense')} className="h-32 bg-red-50 border-2 border-red-200 rounded-xl hover:bg-red-100 flex flex-col items-center justify-center gap-2">
                                    <Skull className="w-8 h-8 text-red-600" /><span className="font-black text-red-800">OFFENSE</span>
                                </button>
                                <button onClick={() => drawCard('defense')} className="h-32 bg-blue-50 border-2 border-blue-200 rounded-xl hover:bg-blue-100 flex flex-col items-center justify-center gap-2">
                                    <Shield className="w-8 h-8 text-blue-600" /><span className="font-black text-blue-800">DEFENSE</span>
                                </button>
                              </div>
                            )}
                          </div>
                        </div>
                        <div className="bg-gray-900 text-green-400 font-mono text-sm p-4 rounded-2xl shadow-lg h-48 overflow-y-auto border-4 border-gray-800">
                          {logs.map((log, i) => (<div key={i} className="mb-2 border-b border-gray-800 pb-2 flex gap-2"><span className="opacity-40 select-none text-xs mt-0.5">{i+1}.</span><span>{log}</span></div>))}
                          <div ref={logEndRef} />
                        </div>
                      </div>
                      <div className="lg:col-span-7 bg-slate-100 p-6 rounded-3xl shadow-inner border border-slate-200 flex flex-col">
                        <div className="flex justify-between items-center mb-4">
                          <h3 className="font-bold text-gray-500 text-sm uppercase tracking-wide flex items-center gap-2"><Utensils className="w-4 h-4" /> {players[currentPlayerIdx].name}'s Hand</h3>
                          <span className="bg-slate-200 text-slate-600 px-2 py-1 rounded text-xs font-bold">{players[currentPlayerIdx].cards.length} Cards</span>
                        </div>
                        <div className="flex-1 overflow-x-auto pb-4 custom-scrollbar">
                          {players[currentPlayerIdx].cards.length === 0 ? (
                             <div className="h-full min-h-[200px] flex flex-col items-center justify-center text-gray-400 border-2 border-dashed border-gray-300 rounded-xl bg-slate-50/50"><Dna className="w-10 h-10 mb-2 opacity-20" /><span className="font-medium italic">Empty Hand</span></div>
                          ) : (
                            <div className="flex gap-4 px-2 min-h-[220px] items-center">
                              {players[currentPlayerIdx].cards.map((card, idx) => (<Card key={idx} card={card} isSelected={selectedCard?.index === idx} onClick={() => { if (phase === GAME_PHASES.START_TURN) playCard(idx); }} />))}
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                  </>
                )}
              </main>
            </div>
          );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<PrebegSpanksGiving />);
    </script>
</body>
</html>
